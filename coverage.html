
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/geebytes/go-scrapy/core/downloader.go (87.2%)</option>
				
				<option value="file1">github.com/geebytes/go-scrapy/core/engine.go (80.0%)</option>
				
				<option value="file2">github.com/geebytes/go-scrapy/core/request.go (73.8%)</option>
				
				<option value="file3">github.com/geebytes/go-scrapy/core/response.go (83.3%)</option>
				
				<option value="file4">github.com/geebytes/go-scrapy/core/spider.go (0.0%)</option>
				
				<option value="file5">github.com/geebytes/go-scrapy/logging/logger.go (94.7%)</option>
				
				<option value="file6">github.com/geebytes/go-scrapy/settings/settings.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package core

import (
        "context"
        "crypto/tls"

        logger "github.com/geebytes/go-scrapy/logging"
        "github.com/sirupsen/logrus"
        "github.com/valyala/fasthttp"
        "github.com/valyala/fasthttp/fasthttpproxy"
)

type Downloader interface {
        Do(ctx context.Context, request *Request) (*Response, error)
        Download(ctx context.Context, request *Request) (*Response, error)
}

type SpiderDownloader struct{}

type Result struct {
        Error    error
        Response *Response
}

const (
        GET     string = "GET"
        POST    string = "POST"
        PUT     string = "PUT"
        DELETE  string = "DELETE"
        OPTIONS string = "OPTIONS"
)

var log *logrus.Entry = logger.GetLogger("downloader")
var GoSpiderDownloader *SpiderDownloader = &amp;SpiderDownloader{}

func (d *SpiderDownloader) Download(ctx context.Context, request *Request, result chan Result) <span class="cov8" title="1">{
        r := Result{}
        req := fasthttp.AcquireRequest()
        resp := fasthttp.AcquireResponse()
        defer func() </span><span class="cov8" title="1">{
                // Release response resource
                fasthttp.ReleaseResponse(resp)
                // Release request resource
                fasthttp.ReleaseRequest(req)
                close(result)
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        log.Errorf("panic recover! p: %v", p)
                }</span>

        }()

        <span class="cov8" title="1">req.Header.SetMethod(request.Method)
        req.SetRequestURI(request.Url)
        // Set request body
        if len(request.Body) != 0 </span><span class="cov8" title="1">{
                req.SetBody(request.Body)
        }</span>
        // Set request headers
        <span class="cov8" title="1">for key, value := range request.Header </span><span class="cov8" title="1">{
                req.Header.Set(key, value)
        }</span>
        // Set tls设置
        <span class="cov8" title="1">c := &amp;fasthttp.Client{
                TLSConfig: &amp;tls.Config{
                        InsecureSkipVerify: request.TLS,
                },
        }
        // set cookies
        if len(request.Cookies) != 0 </span><span class="cov8" title="1">{
                for key, value := range request.Cookies </span><span class="cov8" title="1">{
                        req.Header.SetCookie(key, value)

                }</span>
        }
        // Set request proxy without protocol
        <span class="cov8" title="1">if len(request.Proxy) != 0 </span><span class="cov8" title="1">{
                c.Dial = fasthttpproxy.FasthttpHTTPDialer(request.Proxy)
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Infof("request is done")
                        return</span>
                default:<span class="cov8" title="1">
                        if err := c.DoTimeout(req, resp, request.Timeout); err != nil </span><span class="cov0" title="0">{
                                // log.Errorf("request %s error %s:", request.Url, err.Error())
                                //return nil, err
                                r.Response = nil
                                r.Error = err
                                result &lt;- r
                                return
                        }</span>
                        <span class="cov8" title="1">b := resp.Body()
                        var header map[string][]byte = make(map[string][]byte)

                        resp.Header.VisitAll(func(key, value []byte) </span><span class="cov8" title="1">{
                                header[string(key)] = value
                        }</span>)
                        <span class="cov8" title="1">r.Response = &amp;Response{
                                Text:   resp.String(),
                                Status: resp.StatusCode(),
                                Body:   b,
                                Header: header,
                                Req:    request,
                        }
                        log.Infof("Request is successful")
                        r.Error = nil
                        result &lt;- r</span>
                }
        }
}

func (d *SpiderDownloader) Do(ctx context.Context, request *Request, result chan Result) <span class="cov8" title="1">{
        d.Download(ctx, request, result)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "sync"

        "github.com/geebytes/go-scrapy/middlewares"
        "github.com/geebytes/go-scrapy/pipelines"
)

type SpiderEnginer struct {
        SpidersModules map[string]*SpiderProcesser
        DownloaderMiddliers map[string] *middlewares.DownloadMiddlewares
        SpidersMiddliers map[string] *middlewares.SpidersMiddlewares
        Pipelines map[string] *pipelines.Pipelines

}

var Enginer *SpiderEnginer
var once sync.Once

func NewSpiderEnginer() *SpiderEnginer <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                Enginer = &amp;SpiderEnginer{}
        }</span>)
        <span class="cov8" title="1">return Enginer</span>
}

func (s *SpiderEnginer) Register(name string, spider *SpiderProcesser) <span class="cov0" title="0">{
        s.SpidersModules[name] = spider
}</span>
func init()<span class="cov8" title="1">{
        Enginer = NewSpiderEnginer()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "encoding/json"
        "fmt"
        "net/url"
        "time"

        logger "github.com/geebytes/go-scrapy/logging"
        "github.com/sirupsen/logrus"
)

// Request a url
type Request struct {
        Url     string            // Request URL
        Header  map[string]string // Request header
        Method  string            // Request Method
        Body    []byte            // Request body
        Params  map[string]string // Request query params
        Proxy   string            // Request proxy addr
        Cookies map[string]string
        Timeout time.Duration
        TLS     bool
        Meta    map[string]interface{}
}
type Option func(r *Request)

var reqLog *logrus.Entry = logger.GetLogger("request")

func WithRequestBody(body map[string]interface{}) Option <span class="cov8" title="1">{
        return func(r *Request) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if p := recover(); p != nil </span><span class="cov0" title="0">{
                                reqLog.Errorf("panic recover! p: %v", p)
                        }</span>
                }()
                <span class="cov8" title="1">var err error
                r.Body, err = json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        reqLog.Errorf("set request body err %s", err.Error())
                        panic(fmt.Sprintf("set request body err %s", err.Error()))</span>
                }
        }
}
func WithRequestParams(params map[string]string) Option <span class="cov8" title="1">{
        return func(r *Request) </span><span class="cov8" title="1">{
                r.Params = params

        }</span>
}
func WithRequestProxy(proxy string) Option <span class="cov8" title="1">{
        return func(r *Request) </span><span class="cov8" title="1">{
                r.Proxy = proxy
        }</span>
}
func WithRequestHeader(header map[string]string) Option <span class="cov8" title="1">{
        return func(r *Request) </span><span class="cov8" title="1">{
                r.Header = header
        }</span>
}
func WithRequestCookies(cookies map[string]string) Option <span class="cov8" title="1">{
        return func(r *Request) </span><span class="cov8" title="1">{
                r.Cookies = cookies
        }</span>
}
func WithRequestTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(r *Request) </span><span class="cov0" title="0">{
                r.Timeout = timeout
        }</span>
}
func WithRequestTLS(tls bool) Option <span class="cov8" title="1">{
        return func(r *Request) </span><span class="cov8" title="1">{
                r.TLS = tls
        }</span>
}
func WithRequestMethod(method string) Option <span class="cov0" title="0">{
        return func(r *Request) </span><span class="cov0" title="0">{
                r.Method = method
        }</span>
}
func WithRequestMeta(meta map[string]interface{}) Option <span class="cov0" title="0">{
        return func(r *Request) </span><span class="cov0" title="0">{
                r.Meta = meta
        }</span>
}
func (r *Request) updateQueryParams() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        reqLog.Errorf("panic recover! p: %v", p)
                }</span>
        }()
        <span class="cov8" title="1">if len(r.Params) != 0 </span><span class="cov8" title="1">{
                u, err := url.Parse(r.Url)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("set request query params err %s", err.Error()))</span>
                }
                <span class="cov8" title="1">q := u.Query()
                for key, value := range r.Params </span><span class="cov8" title="1">{
                        q.Set(key, value)
                }</span>
                <span class="cov8" title="1">u.RawQuery = q.Encode()
                r.Url = u.String()</span>
        }
}
func NewRequest(url string, method string, opts ...Option) *Request <span class="cov8" title="1">{
        request := &amp;Request{
                Url:     url,
                Header:  map[string]string{},
                Method:  method,
                Body:    []byte{},
                Params:  map[string]string{},
                Proxy:   "",
                Cookies: map[string]string{},
                Timeout: 10 * time.Second,
                TLS:     false,
                Meta:    map[string]interface{}{},
        }
        for _, o := range opts </span><span class="cov8" title="1">{
                o(request)
        }</span>
        <span class="cov8" title="1">request.updateQueryParams()
        return request</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "encoding/json"

        logger "github.com/geebytes/go-scrapy/logging"
        "github.com/sirupsen/logrus"
)

type Response struct {
        Text   string
        Status int
        Body   []byte
        Header map[string][]byte
        Req    *Request
}

var respLog *logrus.Entry = logger.GetLogger("response")

func (r *Response) Json() map[string]interface{} <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        respLog.Errorf("panic recover! p: %v", p)
                }</span>

        }()
        <span class="cov8" title="1">jsonResp := map[string]interface{}{}
        json.Unmarshal(r.Body, &amp;jsonResp)
        return jsonResp</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package core

type Spider struct{
        Name string // spdier name
        Urls []string  // Feeds url
}
func NewSpider(name string, urls []string) * Spider<span class="cov0" title="0">{
        return &amp;Spider{
                Name: name,
                Urls: urls,
        }
}</span>
type SpiderProcesser interface {
        StartRequest() error
        Parser() (ItemProcesser, error)
        ErrorHandler()

}

</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/geebytes/go-scrapy/settings"

        "github.com/google/uuid"
        "github.com/rifflock/lfshook"
        "github.com/sirupsen/logrus"
)

var Logger = logrus.New()
var ProcessId string = uuid.New().String()

type DefaultFieldHook struct {
}

func (hook *DefaultFieldHook) Fire(entry *logrus.Entry) error <span class="cov8" title="1">{
        u4 := uuid.New()
        name, _ := os.Hostname()
        entry.Data["appName"] = "go-scrapy"
        entry.Data["uuid"] = u4.String()
        entry.Data["hostname"] = name
        entry.Data["processId"] = ProcessId
        return nil
}</span>

func (hook *DefaultFieldHook) Levels() []logrus.Level <span class="cov8" title="1">{
        return logrus.AllLevels
}</span>
func GetLogger(loggerName string) *logrus.Entry <span class="cov8" title="1">{
        log := Logger.WithFields(logrus.Fields{
                "logName": loggerName,
        })
        return log
}</span>
func init() <span class="cov8" title="1">{
        // 设置路径
        pathMap := lfshook.PathMap{
                logrus.InfoLevel:  filepath.Join(settings.Config.Log.Path, "info.log"),
                logrus.PanicLevel: filepath.Join(settings.Config.Log.Path, "error.log"),
                logrus.ErrorLevel: filepath.Join(settings.Config.Log.Path, "error.log"),
                logrus.FatalLevel: filepath.Join(settings.Config.Log.Path, "error.log"),
                logrus.DebugLevel: filepath.Join(settings.Config.Log.Path, "debug.log"),
        }
        // 设置日志格式为json格式
        Logger.Formatter = &amp;logrus.JSONFormatter{TimestampFormat: "2006-01-02 15:04:05"}
        Logger.SetOutput(os.Stdout)
        level, err := logrus.ParseLevel(settings.Config.Log.Level)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("fatal error parse level: %s", err))</span>
        }
        <span class="cov8" title="1">Logger.SetLevel(logrus.Level(level))
        Logger.Hooks.Add(lfshook.NewHook(pathMap, &amp;logrus.JSONFormatter{TimestampFormat: "2006-01-02 15:04:05"}))
        Logger.Hooks.Add(&amp;DefaultFieldHook{})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package settings

import (
        "fmt"
        "path/filepath"
        "runtime"

        "github.com/spf13/viper"
)

type Settings interface {
        GetValue(key string) (error, string)
}

type Logger struct {
        Path  string `yaml:"path"`
        Level string `yaml:"level"`
}

type Configuration struct {
        Log *Logger `ymal:"log"`
}

func (l *Logger) GetValue(key string) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

var Config Configuration

func init() <span class="cov8" title="1">{
        _, filename, _, _ := runtime.Caller(0)

        runtimeViper := viper.New()

        runtimeViper.AddConfigPath(filepath.Dir(filepath.Dir(filename)))
        runtimeViper.SetConfigName("settings")
        runtimeViper.SetConfigType("yaml")
        readErr := runtimeViper.ReadInConfig()
        if readErr != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("fatal error config file: %s", readErr))</span>
        }
        <span class="cov8" title="1">runtimeViper.Unmarshal(&amp;Config)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
